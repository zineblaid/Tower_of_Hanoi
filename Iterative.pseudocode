Procedure IterativeHanoi(n, S, A, D);
var temp, m, t;
Begin;
    // Calculate total number of moves required 2^n - 1;
    totalMoves <-- 2^n - 1;

    // If number of disks is even donc on swap auxiliary and destination pegs;
    If n mod 2 <-- 0 then;
        temp <-- D;
        D <-- A;
        A <-- temp;
    EndIf;

    // Initialize stacks;
    // S_stack starts with all disks (largest at bottom, smallest on top);
    S: stack of disks;      // top of stack at index 1;
    S.top <-- 1;
    A: STACK;   
    A.top <-- 0;
    D: stack;    
    D.top <-- 0;

    // Loop through each move from 1 to totalMoves;
    For m <-- 1 to totalMoves;
        // Move between Source (S_stack) and Destination (D_stack);
        If m mod 3 <-- 1 then;
            If S.top <-- 0 then;
                // Source is empty, move disk from Destination to Source;
                D.top <-- D.top - 1;
                S.top <-- S.top + 1;
                S[S.top] <-- D[D.top + 1];
            ElseIf D.top <-- 0 then;
                // Destination is empty, move disk from Source to Destination;
                S.top <-- S.top - 1;
                D.top <-- D.top + 1;
                D[D.top] <-- S[S.top + 1];
            ElseIf S[S.top] < D[D.top] then;
                // Top disk on Source is smaller, move it to Destination;
                S.top <-- S.top - 1;
                D.top <-- D.top + 1;
                D[D.top] <-- S[S.top + 1];
            Else;
                // Top disk on Destination is smaller, move it to Source;
                D.top <-- D.top - 1;
                S.top <-- S.top + 1;
                S[S.top] <-- D[D.top + 1];
            EndIf;
        
        // Move between Source (S_stack) and Auxiliary (A_stack);
        ElseIf m mod 3 <-- 2 then;
            If S.top <-- 0 then;
                A.top <-- A.top - 1;
                S.top <-- S.top + 1;
                S[S.top] <-- A[A.top + 1];
            ElseIf A.top <-- 0 then;
                S.top <-- S.top - 1;
                A.top <-- A.top + 1;
                A[A.top] <-- S[S.top + 1];
            ElseIf S[S.top] < A[A.top] then;
                S.top <-- S.top - 1;
                A.top <-- A.top + 1;
                A[A.top] <-- S[S.top + 1];
            Else;
                A.top <-- A.top - 1;
                S.top <-- S.top + 1;
                S[S.top] <-- A[A.top + 1];
            EndIf;

        // Move between Auxiliary (A_stack) and Destination (D_stack);
        Else;
            If A.top <-- 0 then;
                D.top <-- D.top - 1;
                A.top <-- A.top + 1;
                A[A.top] <-- D[D.top + 1];
            ElseIf D.top <-- 0 then;
                A.top <-- A.top - 1;
                D.top <-- D.top + 1;
                D[D.top] <-- A[A.top + 1];
            ElseIf A[A.top] < D[D.top] then;
                A.top <-- A.top - 1;
                D.top <-- D.top + 1;
                D[D.top] <-- A[A.top + 1];
            Else;
                D.top <-- D.top - 1;
                A.top <-- A.top + 1;
                A[A.top] <-- D[D.top + 1];
            EndIf;
        EndIf;
    EndFor;
End;
